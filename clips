#!/usr/bin/perl

use FindBin;
use lib "$ENV{'HOME'}/bin", "$ENV{'HOME'}/lib", $FindBin::Bin;

=head1 NAME

clips - Make a video file out of clips from other videos

=cut

my($VERSION)='0.9';

use POSIX;
use List::Util;
use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use File::Temp;
use FFUtils;

=head1 SYNOPSIS

clips [options] <out.mp4|-> <in1.mp4> <clip1> [...]

=head2 Options

=over 8

=item -0 <file>, -1 <file>, -2 <file>, ..., -9 <file>

Numbers (only 0 through 9) can take a filename as an argument to create a
placeholder input file.  This placeholder can then be used to refer to a file.
It is useful if you plan to alternate files a lot on your command-line.  When
using this option, files can be referred to by their number using the
placeholder syntax on the command-line:  C<[0]>, C<[1]>, ..., C<[9]>.  This
will have the effect of substituting the actual filename in for that position.

Note that this option and resulting syntax can be intermixed with the
standard method of placing the filename on the command-line when it is
to become named.  So, even though there are only 10 file name placeholders,
using these options are not fully incompatible with complex command-lines.

=item -title=<text>

Set the output file's C<TITLE> metadata to C<text>.

=item -comment=<text>

Set the output file's C<COMMENT> metadata to C<text>.

=item -description=<text>

Set the output file's C<DESCRIPTION> metadata to C<text>.

=item -o <option> or -overlay=<option>

When performing a video overlay use C<option> to affect the type and
method of overlaying.  Three different kinds of overlay are possible
depending on if C<option> is an integer, coordinates, or a color.

=item -t <#> or -transition=<#>

Change the default transition time for clip transitions from the default of
C<0.8> seconds.

=item -T <type> or -transition-type=<type>

Change the default transition type from C<fade> to C<type>.  Transition
type can either be specified using the one-letter abbreviations or the
full name, as defined in L<ffmpeg-filters(1)>.

=item -f <#> of -fade=<#>

Change the default fade in and out time from C<3> seconds to C<#>.

=item -s <#> or -speed=<#>

Change the default for the C<speed> token from the default of 1 to C<#>.
Note that this also changes the default starting speed for all videos.

=item -v <#> or -volume=<#>

Change the default for the C<volume> token from the default of 1 to C<#>.
This option changes the default starting volume, also.

=item -N or -normalize

Run an audio normalize routine on all inputs.

=item -r <W>:<H> or -resolution=<W>:<H>

Force the inputs AND outputs to be specifically resolution of WxH.  This is
most convenient if you have videos of different resolutions that you want to
merge into one.  However, it can also be used if you want to change the
overall output resolution.  You can use C<:> or C<x> as the delimiter.

Note when using a horizontal or vertical group, this will scale each video
to the desired output resolution, then scale the overall video back down
to the desired size.  It works well as an easy button, but may produce
unintended artifacts.

=item -F <font> or -font=<font>

When drawing text use C<font>.  This could be any font specification
understood by L<ffmpeg(1)> and the L<ffmpeg-filters(1)> C<drawtext>
filter.  See below under L<Fonts> for more information on how B<clips>
searches for fonts.  If that interface is unavailable (it uses Fontconfig)
what works best is to specify a path to a TureType (TTF) font
file.

=item -R <#> or -rate=<#>

Specify that the resulting frame rate should be <#>.

=item -A or -audio-only

Produce only the audio output, no video

=item -P or -practice

This option is just a synonym for C<-resolution=640:360 -rate=24>.

=item -E <#> or -end=<#>

End the video after C<#> time.  Time can be specified in any supported
format.  This option is useful for testing just an initial portion of
the video or to cut it off at a maximum time limit.

=item -U <userfile> or -user=<userfile>

Supply a userfile of your own tokens to extend B<clips> capabilities or
act as aliases/shortcuts for L<ffmpeg(1)> functions.

=item -O <options> or -ffmpeg=<options>

Pass through C<options> as arguments to the L<ffmpeg(1)> command.  Mostly,
this is nice to specific which encoder, muxer, etc to use.  Note that
this optin can be used multiple times, but also, any whitespace within
the argument C<options> string will be used to seperate L<ffmpeg(1)>
arguments.

=item -print=<string>

Display specific information about B<clips>, then exit.  The following
values of C<string> are accepted:

=over 8

=item defaults - print defaults for command-line options

=item order    - print the order filters will be run

=item tree     - print only the data tree structure

=item command  - print only the L<ffmpeg(1)> command

=item usage    - print the B<clips> usage manual section

=item help     - print the B<clips> manual

=item examples - Print B<clips> examples

=item fonts    - If your system has Fontconfig installed, list available fonts

=back

=item -n or -dry-run

Display information about what would be done, then exit.

=item -d or -debug

Display more information to the screen about processing.  Most notably,
print the L<ffmpeg(1)> command to the screen before execution.  This
argument can be supplied sucessive times to increase the information
displayed regarding B<clips> execution.

=item -V or -version

Display Version and exit.

=item -e or -examples

Print the B<EXAMPLES> section of the manual.  This section is the best
place to go to to learn about different ways to run B<clips>.

=item -h or -help

Print a usage statement help information from the manual.

=item -H or --manual

Print full manual.

=back

=cut

my(@OPTIONS)=qw(
	0=s
	1=s
	2=s
	3=s
	4=s
	5=s
	6=s
	7=s
	8=s
	9=s
	title=s
	comment=s
	description=s
	overlay|o=s
	transition|transition-time|transitions|t=f
	transition-type|transitiontype|ttype|T=s
	fade|fade-time|fadetime|f=f
	speed|speedup|tempo|s=f
	volume|vol|v=f
	normalize|normal|norm|N
	resolution|res|geometry|r=s
	rate|framerate|frame-rate|fps|R=f
	font|F=s
	audio-only|A
	practice|P
	end|E=s
	ffmpeg|options|O=s@
	userfile|aliases|alias|U=s
	print=s@
	dry-run|dryrun|n
	debug|verbose|d+
	version|V
	examples|example|e
	help|h
	manual|H
);
my(%ARG)=(
	'overlay'			=> 33,
	'transition'		=> 0.8,
	'transition-type'	=> 'fade',
	'fade'			=> 3,
	'speed'			=> 1,
	'volume'			=> 1,
	'userfile'		=> $ENV{'CLIPS_USERFILE'},
);

Getopt::Long::Configure('pass_through', 'bundling_override', 'ignore_case');
unless(GetOptions(\%ARG, @OPTIONS)) {
	pod2usage(-verbose => 1, -exitval => 1);
}

if($ARGV[0]=~m/^-\w/) {
	&err(2, 'Unrecognized command-line parameter:', $ARGV[0]);
}

$ARG{'print'}=join(',', @{$ARG{'print'}});

if($ARG{'print'}=~m/defaults/i || $ARG{'debug'}>4) {
	print "Defaults:\n";
	foreach my $key (sort(keys(%ARG))) {
		printf("%16s = %s\n", $key, $ARG{$key});
	}
	if($ARG{'print'}=~m/defaults/i) {
		exit(0);
	} else {
		print "\n";
	}
}

my(@MPV)=qw(mpv --osd-fractions --msg-level=cplayer=no,statusline=status);
my(@WATCH)=();

my($DST)=shift;
my($JFH, $JUNK);
my(%SOURCES)=();
my($ROOT)=undef;
my(@INPUTS)=();
my(@FFPROGRAM)=();

if($ARG{'practice'}) {
	$ARG{'resolution'}='640:360';
	$ARG{'rate'}=24;
}

if($ARG{'audio-only'}) {
	$ARG{'rate'}=0.1;
}

#Developer's note for filters:
#Any `simple:video:*` or `simple:audio:*` filters should accept only one
#input and produce only one output.  They will be chained together for you,
#and should, therefore, not have labels and just return a sequence of
#filters to be chained together.
#
#Any `group:*` and `complex:*` filters will not receive automated labels,
#and you need to #manage that yourself, along with updating
#$node->{'video'} and $node->{'audio'}

my(%M)=();	#Filter Match
my(%F)=();	#Filter Functions
my(%UM)=();	#UserFilter Match
my(%UF)=();	#UserFilter Macro Definition

sub debugtreesort {
	my($hash)=@_;
	my(%priority)=qw(
		type      10
		index     11
		step      12
		file      20
		start     21
		end       22
		length    23
		width     24
		height    25
		fps       26
		merge     30
		timer     31
		video     40
		audio     41
		f:a       50
		f:v       51
		f:x       52
		parent    60
		tree      zz
	);

	return([sort(
		{ ($priority{$a}.$a||$a) cmp ($priority{$b}.$b||$b) } keys(%$hash)
	)]);
}

sub debugcollapse {
	my($string)=@_;
	$string=~s/\s+/ /gs;
	return($string);
}

sub treedump {
	my($tree);

	$Data::Dumper::Indent=1;
	$Data::Dumper::Terse=1;
	$Data::Dumper::Pair = ":  ";
	$Data::Dumper::Quotekeys=0;
	$Data::Dumper::Sortkeys=\&debugtreesort;
	$tree=Dumper($ROOT);

	$tree=~s/VAR1/ROOT/g;
	$tree=~s/(:|=>) +\!\!([01]),/: $1,/g;
	$tree=~s/(\n\s+)(\[.*?\s*\])/$1.&debugcollapse($2)/ges;
	$tree=~s/((:|=>) +\[\n\s+[^}]{1,30}\n\s+\])/&debugcollapse($1)/ges;
	$tree=~s/^{/ {/;
	$tree=~s/}$/ }/;

	print "Data Structure Tree:\n", $tree, "\n\n";
}

#err just makes it simpler to print error messages and exit with a specific
#error code.
sub err {
	my($code)=shift;

	&treedump if($ARG{'debug'}>1);

	print STDERR join(' ', @_), "\n";
	exit($code);
}

#fmt takes an extended `sprintf` string with pound-sign (#) style macros.
#These are substituted in first IF the second argument is a hash ref which
#contains a map of those macros.  After (and otherwise) a normal sprintf
#is run on remaining arguments (if any).
sub fmt {
	my($fmt)=shift;
	my($macro)=(ref($_[0]) eq 'HASH')?shift:undef;
	my($out)=undef;

	if($macro) {
		my($loop)=0;
		while($fmt=~s/(?<!#)#((\w)|{(\w+)})/$macro->{$2||$3}/g) {
			if($loop++ > 100) {
				&err(101, 'Macro expansion loop detected in ', $fmt);
			}
		}
		s/##/#/g;
	}

	if(@_) {
		$out=sprintf($fmt, @_);
		$out=~s/(\d+\.\d{6})/$1+0/eg; #Even if fails, number is still valid
		return($out);
	} else {
		return($fmt);
	}
}

sub even {
	my($i)=int($_[0]);
	return($i + $i%2);
}

sub copykeys {
	my($source, $target, @keys)=@_;

	foreach my $key (@keys) {
		$target->{$key}=$source->{$key};
	}
}

=head2 Fonts

There is support for B<clips> to help you find fonts if Fontconfig is
installed.  Otherwise, font information is just passed along to
L<ffmpeg(1)> to do it's best.  This is very
Linux specific for now, but it would work anywhere that there is
Fontconfig.  Use a combination of C<-print=fonts> and the C<-F>
command-line options to search for and select fonts.  Once you have
the search narrowed to the font you want, you can remove the 
C<-print=fonts> argument and should get what you want.  You can
always still use the C<-n> or C<-d> arguments to see the L<ffmpeg(1)>
command-line for verification.

This interface is very nearly the exact opposite of the Fontconfig
methodology.  So, shh, don't tell them about it.  When you use the
C<-F> command-line argument to specify a font, B<clips> will step
through the font name word by word, limiting the font choices
as it goes.  If it ends with a single font, then it is used.  If
multiple matching fonts are found, then the shortest match is
used.  For example, using the arguments C<-F 'Sans Italic'> will
catch both Font C<Noto Sans> in Style C<Italic> and font C<B&H Lucida>
in style C<Sans Italic>.  Finally, if the last word of your font is
a language specifier (e.g. C<en>) then only fonts supporting that
language will be kept.  So, using C<-print=fonts -F he> will actually
list all fonts supporting Hebrew.

=cut

sub fc_search {
	my(@search)=split(m/\s+/, join(' ', @_));
	my(@fclist)=('fc-list', '-f', '%{family[0]};%{style[0]};%{file}\n');
	my($list)=IO::Handle->new;
	my(%fonts)=();
	my(%match)=();
	my(@font, $name, $lang_re);

	$lang_re=join('|',
		List::Util::uniq(sort(
			split(m/\|/, `fc-list -f '%{lang}'`)
		))
	);

	if($search[-1]=~m/^($lang_re)$/i) {
		push(@fclist, &fmt(':lang=%s', pop(@search)));
	}

	open($list, '-|', @fclist);
	while(<$list>) {
		chomp;
		@font=split(m/;/);

		$fonts{join(' ', @font[0,1])}=[@font];
	}
	close($list);

	if($?) {
		if($ARG{'debug'}>1) {
			print "Fontconfig is not installed or not working\n";
		}
		return();
	}

	if(@search) {
		foreach my $term (@search) {
			foreach $name (keys(%fonts)) {
				delete($fonts{$name}) unless($name=~m/$term/i);
			}

			if(%fonts) {
				%match=%fonts;
			} else {
				#That term failed, move on to the next one
				%fonts=%match;
			}
		}

		return(%match);
	} else {
		return(%fonts);
	}

}

sub find_font {
	my($font)=join(' ', @_);
	my(@matches);
	my(%fonts);

	if(-r $font) {
		return($font, undef);
	} elsif($font) {
		%fonts=&fc_search($font);

		if(%fonts) {
			@matches=sort({ length($a) <=> length($b) } keys(%fonts));
			return($fonts{$matches[0]}[2], $matches[0]);
		} else {
			return(undef, $font);
		}
	} else {
		return(undef, 'Sans');
	}
}

sub print_fonts {
	my(%fonts)=&fc_search(@_);
	my(%print)=();

	print "Font list:\n";

	unless(%fonts) {
		print " None found for search: @_\n";
		return();
	}

	foreach my $font (values(%fonts)) {
		$print{$font->[0]}//=[];
		unless($font->[1]=~m/regular/i) {
			push(@{$print{$font->[0]}}, $font->[1]);
		}
	}

	foreach my $font (sort(keys(%print))) {
		my(@styles)=sort( { length($a) <=> length($b) } @{$print{$font}});
		my($i)=$#styles;

		do {
			if($i==0 || length(join(', ', @styles[0..$i])) < 48) {
				print &fmt(" %-30s %s\n",
					$font, join(', ', splice(@styles, 0, $i+1)));
				$i=$#styles;
			} else {
				$i--;
			}
		} while(@styles);
	}
}

=head1 DESCRIPTION

The purpose of B<clips> is to create video files from other video files
using L<ffmpeg(1)>.  The syntax is meant to be intuitive and lightweight,
two things which cannot be said about L<ffmpeg(1)>'s syntax.  This tool
is great for amateur videographers who want to put up a YouTube video or
just create a clip from their phone to post to reddit for help troubleshooting
something. Specifying a time is a core part of B<clips>, and all time
specifications adhere to the syntax outlined in L<ffmpeg-utils(1)>.

This is not meant to be a user-friendly tool and replace high-end video
editing software.  It has lots of defaults for audio normalization which
are fine for use as a basic software tool.  All audio channels are merged
down to the front two stereo channels.  This leaves room to easilly go in
afterwards to layer a voice track and background music really easilly.

If you need to remove/change/add to the C<ffmpeg> command, you can always
run B<clips> with the C<-n> or C<-dry-run> command-line options to see the
command which would have been executed.  Then, feel free to edit that for
any necessary changes.

B<clips> assumes all files are at the same resolution and keeps that
resolution for the final product.  As, the tool is most often used on a
single file, this will be clearly the case.  However, if you have multiple
files of different resolutions, or you would like the final product to be
a specific resolution, then you can use the C<-resolution> command-line
option to specify a resolution.  However, please note that B<clips> doesn't
play with aspect ratios.  If the files do not conform to the desired
ratio, then the output will be padded with black bars.  The C<scale>
(see below) token can also be used to fix any specific segments.

=head2 Transitions

One cool feature of B<clips> is that it can transition (aka fade) between
clips.  Both audio and video are faded together.  You can specifiy a
video transition style; however, audio transition is hard-coded.
When using transitions, a set of short-codes is supported or transitions
can be listed using their full names.  The following short-codes are
supported:

=over 8

=item f - fade

=item g - fadegrays

=item d - dissolve

=item p - pixelize

=item b - fadeblack

=item z - zoomin

=item o - circleopen

=item U - slideup

=item D - slidedown

=item L - slideleft

=item R - slideright

=back

=cut

my(%TRANSITION)=(
	'f'	=> 'fade',
	'g'	=> 'fadegrays',
	'd'	=> 'dissolve',
	'p'	=> 'pixelize',
	'b'	=> 'fadeblack',
	'z'	=> 'zoomin',
	'o'	=> 'circleopen',
	'U'	=> 'slideup',
	'D'	=> 'slidedown',
	'L'	=> 'slideleft',
	'R'	=> 'slideright',
);


=head2 Time Format

Specifying times is critical to using B<clips>.  And the syntax follows
L<ffmpeg(1)> time specification grammar.  Times can be specified as
floating-point numbers in total seconds (e.g. 345.963) or in the standard
human readable format (e.g. 6:45.963) which may optionally include minutes
and hours.  In all cases, fractions are optional, but if you don't specify
them, then ffmpeg will just select the closest frame (and that may not be
what you want).

=head2 Tokens

After the output file is specified, each command-line argument is a token
which is processed to affect the final rendering.  The following tokens
are supported:

=over 8

=item <filename>

Any filename specified after the output file (and you need to do this at
least once) will mean that any clips specified after this file will come
from it.  You can change the filename as many times as you want, and you
can come back and repeat at filename if you wish.

=item <[#]> or <[#:<a|v>]>

When using the C<-0>, C<-1>, ..., C<-9> command-line arguments, this syntax
can be used as a placeholder to reference the corresponding file name as
C<#> with a short token like C<[1]>.  This token can be an argument by
itself, or be bolted onto the front of a clip time specification.

Optionally, you can simulate L<ffmpeg(1)> syntax and either pull out only
the audio track (e.g. C<[0:a]>) or mute the audio track (e.g. C<[2:v]>)
for the next clip of this file.  This shorthand only only affects the next
clips and so should be used carefully.

=item fps[/framerate]

Set the Frames Per Second to a specified value, or the default as
defined globally via the C<-R> or C<-rate> command-line options.

=cut

$M{'simple:video:fps'}='fps/?([\d./]*)';
$F{'simple:video:fps'}=sub {
	my($node, $fps)=@_;

	$fps||=$ARG{'rate'};

	if($fps != $node->{'fps'}) {
		$node->{'fps'}=$fps;
		return(&fmt('fps=fps=%f,settb=AVTB', $fps));
	}
};

=item text[/color][/fontsize][/duration][/position]</string>

Display C<string> over the image.  The defaults for this are to use
a large, black text in the center of the screen for the duration of
the video.  Arguments can be supplied in any order, and B<clips>
will look at the argument to decide which type it is.  Arguments
left off will use defaults.  B<clips> attempts to recognize arguments
in the following order, but they do not have to be used that way.

=over 8

=item color

The Color may be specified either in the hexidecimal C<#000000> or using
standard color names listed in L<ffmpeg-utils(1)>.  After the color name
or number, an at symbol (@) may come with a number between C<0> and
C<1> to specify the alpha component.  Following normal convention, C<0>
is fully transparent and C<1> is solid.  Additionally, the hexidecmal
notation may contain 8 numbers, with the last two specifying the alpha
using standard hexidecimal color notation.

=item fontsize

The fontsize is either a number followed by the letters C<pt> (e.g. C<96pt>)
or a suported L<ffmpeg-filters(1)> C<drawtext> formula followed by C<pt>
(e.g. C<(h\/10)pt>).

=item duration

By default, text will be positioned over the entire video segment.  To
limit that, use this argument.  It should be a C<time> format, the same
as a segment syntax.  Just like segments, a syntax like C<0:04.030-> would
go form 4.030 seconds to the end of the video segment.  Note that this is
based on the video stream, and not segment definition.  If you would like
to display text in a video segment defined as C<1:03.390-4:34.960> for
a period of 10 to 2 seconds prior to the end of the video segment, then
the duration would be: C<3:41.630-3:39.630>.  This is necessary as text
may be applied to composite video streams, and this is the only logically
consistant way to specify times.

=item position

The position can be something as simple as specifying the top left corner
of the text box as 100x100 pixels from the image top left corner with
C<100:100>, to using negative numbers to specify distance from other edges
(e.g. C<10,-10> would make the bottom left corner of the text box be 10
pixels from the left side and 10 pixels up from the bottom of the image).

Or, you can use one of six nemonics:  C<left>, C<middle>, C<right> and
C<top>, C<center>, C<bottom> to look like C<bottom:right>.

Lastly, you have pretty much full access to the L<ffmpeg-filters(1)>
drawtext C<x=> and C<y=> parameters (which includes the ability to move
text using the C<t> (time) variable.

Note also, that C<text> comes before C<scale> in processing, so use the
position on the original segment size, ranther the the size as a result
of the C<scale> token.  While this may not seem ideal in all situations,
it is helpful for using the original size to plan and for debugging or
"practice" mode.  If you need this to work otherise, just group it like
C<'text/-256:64/some text' { scale/1920:1080 1:00-2:00 }>.

=item string

This is your text.  It will be quoted, so shouldn't have to worry about any
special characters except for slash (/) character used to seperate
arguments.

=back

Note that many of these arguments may be mathmatical formulas.  AND, a
slash symbol (/) is our seperator.  When dividing, either escape the
symbol (e.g. C<\/>) or instead use the functional notation
C<div(h-text_h,2)>

=cut

$M{'simple:video:text'}='text/?(.*)(?<!\\\)/(.*)';
$F{'simple:video:text'}=sub {
	my($node, $args, $text)=@_;
	my($drawtext)='drawtext=';
	my(%coords)=(
		'top'	=> 'h*0.01',
		'center'	=> '(h-text_h)/2',
		'bottom'	=> 'h*0.99-text_h',
		'left'	=> 'w*0.01',
		'middle'	=> '(w-text_w)/2',
		'right'	=> 'w*0.99-text_w',
	);
	my(%params)=(
		'fontcolor'	=> 'black@0.9',
		'fontsize'	=> 'h/8',
		'x'			=> $coords{'middle'},
		'y'			=> $coords{'center'},
	);

	if($ARG{'font'}) {
		($params{'fontfile'}, $params{'font'})=&find_font($ARG{'font'});
	}

	foreach(split(m|(?<!\\)/|, $args)) {
		s|div\(\s*(.*?)\s*,\s*(.*?)\s*\)|$1/$2|g;

		if(m/^(#[\da-f@]{6,8}|[a-z]+@[\d.]+|[a-z]+)$/i) {
			$params{'fontcolor'}=$1;
		} elsif(m/^(.+)pt$/i) {
			$params{'fontsize'}=$1;
		} elsif(m/^([\d.:]+)-([\d.:]+)?$/) {
			$params{'enable'}=&fmt('between(t,%f,%f)',
				FFUtils::time2secs($1),
				FFUtils::time2secs($2 // $node->{'length'}));
		} elsif(m|^([\w()*\\/+-]+)[:x]([\w()*\\/+-]+)$|i) {
			$params{'x'}=$1;
			$params{'y'}=$2;

			if(exists($coords{$params{'x'}})) {
				if($coords{$params{'x'}}=~m/w/) {
					$params{'x'}=$coords{$params{'x'}};
				} else {
					&err(11, 'Oops, you specified a height where you needed a width');
				}
			}
			if(exists($coords{$params{'y'}})) {
				if($coords{$params{'y'}}=~m/h/) {
					$params{'y'}=$coords{$params{'y'}};
				} else {
					&err(11, 'Oops, you specified a width where you needed a height');
				}
			}

			$params{'x'}="w-text_w+$params{'x'}" if($params{'x'}<0);
			$params{'y'}="h-text_h+$params{'y'}" if($params{'y'}<0);
		} else {
			&err(11, 'drawtext argument not understood:', $_);
		}
	}

	foreach my $key (keys(%params)) {
		$drawtext.="$key='$params{$key}':" if($key && $params{$key});
	}
	$text=~s|\\/|/|g;
	$drawtext.=sprintf("text='%s'", $text);

	return($drawtext);
};

=item crop/W:H:X:Y

Crop the next clip to be C<W> wide, C<H> tall, and start the top-left corner
of the rectangle at coordinates C<X>, C<Y>.  Unlike most tokens, there is no
defaults, and so an argument is required.  Negative C<X> or C<Y> coordinates
will orient the opposite edge from the opposite side of the image.

You can basically use any non-numeric character to seperate the width, height,
and coordinates.

=cut

$M{'simple:video:crop'}='crop/(\d+)\D(\d+)\D([\d+-]+)\D([\d+-]+)';
$F{'simple:video:crop'}=sub {
	my($node, $w, $h, $x, $y)=@_;

	if($x<0) {
		$x+=$node->{'width'}-$w;
	}
	if($y<0) {
		$y+=$node->{'height'}-$h;
	}

	if($w+$x > $node->{'width'}) {
		&err(6, "Cannot crop outside the boundary of the input, too wide.");
	} elsif($h+$y > $node->{'height'}) {
		&err(6, "Cannot crop outside the boundary of the input, too tall.");
	} elsif($w<2 || $h<2) {
		&err(6, "minimum supported height or width is 2px.");
	}

	$node->{'width'}=$w;
	$node->{'height'}=$h;

	return(&fmt('crop=%d:%d:%d:%d', $w, $h, $x, $y));
};

=item scale[/H:W]

Scale the next video to the default height and width, or what is specified
with the token.

Simple right?  Well, C<scale> is far from it.  If there isn't a geometry
specified and there is no command-line argument resolution specified, then
C<scale> will check to see if it is called within a group, and align the
resolution to that of the first member of the group.  Additionally, when
inside a grouping, an implied C<scale> filter is applied to all clips which
don't match the first video's resolution.

The final thing to note about B<clips>' C<scale> token is that it respects
the original aspect ratio, adding black bars if necessary to match the
requested dimensions without altering the aspect ratio.  Use
C<ffmpeg/v/scale> to call L<ffmpeg(1)>'s scale in an unintelligent way,
or see the C<resize> configuration in the example user filter file which
performs an exact user-specified scale operation regardless of how they
might look different than the original.

=cut

$M{'simple:video:scale'}='scale/?([\dx:]*)';
$F{'simple:video:scale'}=sub {
	my($node)=$_[0];
	my($resolution)=$_[1] || $ARG{'resolution'};
	my($parent)=$node->{'parent'};
	my($w, $h)=split(m/[x:]/i, $resolution);
	my($scale)='scale=%d:%d:force_original_aspect_ratio=decrease:reset_sar=1';
	my($pad)='pad=%d:%d:(ow-iw)/2:(oh-ih)/2';

	unless($resolution) {
		if($parent->{'type'} eq 'group') {
			$w=$parent->{'tree'}[0]{'width'};
			$h=$parent->{'tree'}[0]{'height'};
		}
	}

	if($parent && $parent->{'type'} eq 'group' && $parent->{'merge'} ne 'c') {
		if($parent->{'merge'} eq 'h') {
			return() if($node->{'height'}==$h);

			$node->{'width'}=&even($node->{'width'}*$h/$node->{'height'});
			$node->{'height'}=$h;
		} elsif($parent->{'merge'} eq 'v') {
			return() if($node->{'width'}==$w);

			$node->{'height'}=&even($node->{'height'}*$w/$node->{'width'});
			$node->{'width'}=$w;
		} else {
			&err(5, 'Unknown group merge function:', $parent->{'merge'});
		}

		return(&fmt($scale, $node->{'width'}, $node->{'height'}));
	} elsif($node->{'width'}!=$w || $node->{'height'}!=$h) {
		$node->{'width'}=$w;
		$node->{'height'}=$h;
		return(
			&fmt($scale, $w, $h),
			&fmt($pad, $w, $h)
		);
	}

	return();
};

=item flip[/<h|v>]

Flip the video.  The default is a horizontal flip, but specifying an argument
of C<v> will perform a vertical flip.

=cut

$M{'simple:video:flip'}='flip/?([vh]*)';
$F{'simple:video:flip'}=sub {
	my($node, $type)=@_;

	return(&fmt('%sflip', $type || 'h'));
};

=item fade-in[/time]

Perform a fade in for your video.  Technically, this feature can be used
anywhere on the commandline (except for as the last argument) but it makes
the most sense when used as the first argument.  The default is 3 seconds,
but that can be altered (e.g C<fade-in/2.2> would fade in for 2.2 seconds.

Note that any string that starts with C<fade> and ends with C<in> will work
(e.g. fadein, fade:in, etc.).

=item fade-out[/time]

This is basically the same as C<fade-in> except it fades out.  It should
not be used as the first argument.  Uniary tokens should always come before
clip they affect; however, this one (and blur-out) are the exceptions.
This is a rare postfix operator in B<clips>, it actually neesd to come
after the clip it affects; most likely as the last token on the command-line.

=cut

$M{'complex:fade'}='fade.*(in|out)/?([\d.]*)';
$F{'complex:fade'}=sub {
	my($node, $type, $length)=@_;
	my($vout, $aout)=&next_labels($node);
	my(@fade)=();
	my(%macros);

	$length||=$ARG{'fade'};
	$type=lc($type);

	if($length>$node->{'length'}) {
		&err(11, "Fade cannot be longer than the actual clip.");
	}

	%macros=(
		'T'	=> lc($type),
		'S'	=> ($type eq 'out')?$node->{'length'}-$length:0,
		'D'	=> $length,
	);

	push(@fade, &fmt('#{I}fade=t=#{T}:st=#{S}:d=#{D}#{O}', {
		'I'	=> $node->{'tree'}[0]{'video'},
		'O'	=> $vout,
		%macros
	}));
	push(@fade, &fmt('#{I}afade=t=#{T}:st=#{S}:d=#{D}:curve=qua#{O}', {
		'I'	=> $node->{'tree'}[0]{'audio'},
		'O'	=> $aout,
		%macros,
	}));

	$node->{'audio'}=$aout;
	$node->{'video'}=$vout;

	return(@fade);
};

=item blur-in[/time]

Fade into the video with a blur effect.  The video will start very blury
and become crisp over C<time> seconds.  The default duration for this
effect mirrors the C<fade-in> token, with the same command-line parameter
controls.  Note that the image is darkened slightly at the start of the
blur to give it a more familiar feel.

=item blur-out[/time]

Fade out from the video with a blur effect.  The video will start crisp
and become blury over C<time> seconds.  It works the same as C<blur-in>,
just backwards.

Note that this is a rare postfix operator, it must come
after the clip it affects.

=cut

$M{'complex:blur'}='blur.*(in|out)/?([\d.]*)';
$F{'complex:blur'}=sub {
	my($node, $type, $length)=@_;
	my($ifin)=($type=~m/in/i);
	my(@blur)=();
	my($macros);

	$length||=$ARG{'fade'};
	($node->{'video'}, $node->{'audio'})=&next_labels($node);

	if($length>$node->{'length'}) {
		&err(11, "Blur cannot be longer than the actual clip.");
	}

	$macros={
		'Iv'	=> $node->{'tree'}[0]{'video'},
		'Ia'	=> $node->{'tree'}[0]{'audio'},
		'I1'	=> &next_labels($node, 'video'),
		'I2'	=> &next_labels($node, 'video'),
		'T'	=> lc($type),
		'D'	=> $length,
		'C'	=> 'qua',
		'N'	=> 60,
		'B'	=> -0.15,

		'Si'	=> 0,
		'Ri'	=> 'pow(T-#{Si}\,2)/pow(#{D}\,2)',
		'Ai'	=> '(#{Ri})*A+(1-#{Ri})*B',
		'Ei'	=> 'lte(t\,#{D})',

		'So'	=> $node->{'length'}-$length,
		'Ro'	=> 'clip(sqrt((T-#{So})/(#{D}))\,0\,1)',
		'Ao'	=> '(1-#{Ro})*A+(#{Ro})*B',
		'Eo'	=> 'gte(t\,#{So})',

		'S'	=> $ifin ? '#{Si}' : '#{So}',
		'A'	=> $ifin ? '#{Ai}' : '#{Ao}',

		'E'	=> $ifin ? 'enable=#{Ei}' : 'enable=#{Eo}',
		'Ob'	=> &next_labels($node, 'video'),
		'Ov'	=> $node->{'video'},
		'Oa'	=> $node->{'audio'},

	};

	push(@blur, &fmt('#{Ia}afade=t=#{T}:st=#{S}:d=#{D}:curve=#{C}#{Oa}',
		$macros));
	push(@blur, &fmt('#{Iv}split#{I1}#{I2}',
		$macros));
	push(@blur, &fmt('#{I1}gblur=#{N}:#{E},eq=brightness=#{B}:#{E}#{Ob}',
		$macros));
	push(@blur, &fmt('#{I2}#{Ob}blend=all_expr=#{A}:#{E}#{Ov}',
		$macros));

	return(@blur);
};

=item audio

An extremely simple token to extract only the audio content from a clip.
Note, there is no analogous token for videos as man complex filters
expect a video to have audio.  If you need to supress audio from a
video clip, you can use C<v/0> to set the volume to 0.

=cut

$M{'complex:audio'}='audio';
$F{'complex:audio'}=sub {
	my($node)=@_;

	&copykeys($node->{'tree'}[0] => $node, 'audio');

	$node->{'video'}=undef;
	$node->{'fps'}=undef;
	$node->{'width'}=undef;
	$node->{'height'}=undef;

	return();
};

=item denoise[/#]

Apply an audio denoise to the next clip.  Note, that this token is very
special in that it only applies to the very next clip after it.  Optionally,
you can specify a volume function to the denoised audio, the default is
C<2>.

=cut

$M{'simple:audio:denoise'}='denoise/?([\d.]*)';
$F{'simple:audio:denoise'}=sub {
	my($node, $volume)=@_;
	my($denoise)=join(',', qw(
		afftdn=nf=-25
		highpass
		lowpass
		afwtdn
		dialoguenhance
		volume=%f
	));

	$volume//=2;

	return(&fmt($denoise, $volume));
};

=item speed[/time]

Change the default speed for subsequent clips to C<time> or the default
if C<time> is omitted.  This number defaults to 1 (source time) and can
be speed up with (e.g. 1.2) or slowed down by half (e.g. 0.5).  Both audio
and video are adjusted appropriately.

=cut

$M{'complex:speed'}='speed/?([\d.]*)';
$F{'complex:speed'}=sub {
	my($node, $speed)=@_;
	my($diff)=($node->{'length'}/$speed) - $node->{'length'};
	my($vin)=$node->{'tree'}[0]{'video'};
	my($ain)=$node->{'tree'}[0]{'audio'};
	my($vout, $aout)=&next_labels($node);
	my(@speed)=();

	$speed||=$ARG{'speed'};

	push(@speed, &fmt('#{I}setpts=#{S}*PTS#{O}', {
			'I'	=> $vin,
			'S'	=> 1/$speed,
			'O'	=> $vout
		}));
	$node->{'video'}=$vout;

	if($speed<0.5) {
		print "Note, audio is disabled below 0.5\n";
		#&err(10, 'Cannot specify a speed slower than 0.5');
		$node->{'audio'}=undef;
	} else {
		push(@speed, &fmt('#{I}atempo=#{S}#{O}', {
				'I'	=> $ain,
				'S'	=> $speed,
				'O'	=> $aout
			}));
		$node->{'audio'}=$aout;
	}


	return(@speed);
};

=item volume[/#]

Change the default volume for subsequent clips to C<#> or the default
if C<#> is omitted.  This number defaults to 1, which is useful to reset
volume back to "original" volume.  Note that unless overridden, all volume
is normalized  before this, so "original" is only sort-of a true statement.
This token can be shortened all the way to just C<v>, for example, C<v/0>
would mute the next segment.

=cut

$M{'simple:audio:volume'}='v[olume]*/?([\d.]*)';
$F{'simple:audio:volume'}=sub {
	my($node, $volume)=@_;

	if($volume eq '') {
		$volume=$ARG{'volume'};
	}

	if($volume!=1) {
		return(&fmt('volume=%f', $volume));
	} else {
		return();
	}
};

=item normalize/[#]

Run a set of basic normalize audio filters to the next segment.  If
a number is specified, adjust the volume further by this number at the
end of the filter chain.  This filter is great for audio with a lot of
talking and/or background noise.  It is not recommended for music.

=cut

$M{'simple:audio:normalize'}='norm[alize]*/?([\d.]*)';
$F{'simple:audio:normalize'}=sub {
	my($node, $volume)=@_;

	$volume//=$ARG{'volume'};

	return(&fmt('%s,volume=%f', $FFUtils::NORMALIZE, $volume));
};

=item delay/<#>

Add an audio delay of C<#> seconds to the next audio clip or the audio
portion of the next video clip.  Note that this token is different from
most others in that the argument is required and not optional.

=cut

$M{'simple:audio:delay'}='delay/([\d.]+)';
$F{'simple:audio:delay'}=sub {
	my($node, $delay)=@_;

	return(&fmt('adelay=delays=%d:all=1', $delay*1000));
};

=item /[seconds][[/]type]

Perform a transition.  A C</> by itself uses all the defaults.  A time format
and/or a type can be used as an argument.  Examples are C</3.5>,
C</3.5/d>, C</3.5/windlr>, C</L> which fade for the non-default 3.5 seconds,
do so with a dissolve fade, do so with the wind left-to-right, and a standard
0.8 seconds of left fade respectively.

=cut

$M{'complex:transition'}='/([\d.]*)/?([a-zA-Z]*)';
$F{'complex:transition'}=sub {
	my($node, $time, $type)=@_;
	my($l, $r)=($node->{'tree'}[0], $node->{'tree'}[1]);
	my($offset)=$l->{'length'}-$time;
	my(@fade)=();

	&copykeys($l => $node, 'width', 'height', 'fps');
	($node->{'video'}, $node->{'audio'})=&next_labels($node);

	$type=$TRANSITION{$type} || $type;

	if($time>$l->{'length'} || $time>$r->{'length'}) {
		&err(11, "Transition cannot be longer than the actual clip.");
	}

	push(@fade,
		&fmt('#{IL}#{IR}acrossfade=d=#{D}:c1=#{C1}:c2=#{C2}#{O}', {
				'IL'	=> $l->{'audio'},
				'IR'	=> $r->{'audio'},
				'D'	=> $time,
				'C1'	=> 'cbr',
				'C2'	=> 'cub',
				'O'	=> $node->{'audio'}
			}),
		&fmt('#{IL}#{IR}xfade=transition=#{T}:offset=#{S}:duration=#{D}#{O}',{
				'IL'	=> $l->{'video'},
				'IR'	=> $r->{'video'},
				'T'	=> $type,
				'S'	=> $offset,
				'D'	=> $time,
				'O'	=> $node->{'video'}
			}),
	);

	return(@fade);
};

=item %[/][option1][/option2][/option3]

Overlay the video to the right on top of the video to the left.
This token can take any combination of three options, seperated with
C</> characters.

If the optional integer C<n> is specified as a number between 0 and
100, then this is used as the percentage of coverage for the left video.
This defaults to C<66>, for an alpha configuration of C<0.66>. This is
the default mode and produces an image where both inputs are blended
together.

If C<option> is of the form X:Y or XxY, then these will be the X and Y
coordinates of the top left corner of the overlayed image.  This really only
makes sense if the overlayed (left) image is smaller.

Any other C<option> will be treated as an attempt to specify a color to
be treated as an alpha color.  Examples are C<lime>, C<0x00FF00>, and
C<#00FF00>.  The right images will be on top of the left image, with the
left image visible everywhere the color (e.g. lime) is present, and the
right image visible otherwise.  After the color, this option can be
modified by two C<:> seperated arguments.  The first is the percentage
similarity of he color which will be matched for transparence.  Generally,
this should be in the C<0.01-0.05> range.  The second specifies how the
color is blended as an alpha and should also generally be in the
C<0.01-0.05> range.

Note 1 - overlays can be chained, with the base image listed first, and
subsequent overlays specified one after another; each building on top
of the image before it.  They can also be chained with stacked segments.
However, it should be noted that chaining overlays can slow down processing
quite a bit.

Note 2 - you can place a slash C</> character between the percent sign C<%>
and options if you want, or you don't have to.

=cut

$M{'complex:overlay'}='%/?(.*)';
$F{'complex:overlay'}=sub {
	my($node, $config)=@_;
	my($main)=$node->{'tree'}[0];
	my($over)=$node->{'tree'}[1];
	my($alpha, $color, $position)=(undef, undef, 'x=0:y=0');
	my($valpha)=&next_labels($node, 'video' => 1);
	my(@overlay)=();

	&copykeys($main => $node, 'width', 'height', 'fps');
	($node->{'video'}, $node->{'audio'})=&next_labels($node);

	foreach my $option (split(m|/|, $config)) {
		if($option=~m/^\d+$/) {
			$alpha=$option;
			if($alpha<0 || 100<$alpha) {
				&err(8, 'Overlay alpha is out of proper range 0-100');
			}
		} elsif($option=~m/^(0x|#)([\da-f]{6})(:[:\d.]+)?$/i) {
			$color="0x$1$2";
		} elsif($option=~m/^[a-z](:[:\d.]+)?$/i) {
			$color=$option;
		} elsif($option=~m/^([+-]?\w+)[:x]([+-]?\w+)$/i) {
			$position=&fmt('x=%d:y=%d', split(m/[x:]/i, $option));
		}
	}

	push(@overlay,
		&fmt('%s%samix=inputs=2:duration=shortest%s',
			$main->{'audio'}, $over->{'audio'}, $node->{'audio'}),
	);

	if($color) {
		push(@overlay,
			&fmt('%schromakey=%s,colorchannelmixer=aa=%f%s',
				$over->{'video'}, $color, $alpha/100, $valpha),

			&fmt('%s%soverlay=shortest=1:%s%s',
				$main->{'video'}, $valpha, $position, $node->{'video'}),
		);
	} elsif($alpha) {
		push(@overlay,
			&fmt('%sformat=yuva444p,colorchannelmixer=aa=%f%s',
				$over->{'video'}, $alpha/100, $valpha),
			&fmt('%s%soverlay=shortest=1:%s%s',
				$main->{'video'}, $valpha, $position, $node->{'video'}),
		);
	} else {
		push(@overlay,
			&fmt('%s%soverlay=shortest=1:%s%s',
				$main->{'video'}, $over->{'video'}, $position, $node->{'video'}),
		);
	}

	return(@overlay);
};

=item {[/c] <...> }

Braces C<{> and C<}> can be used to create Grouped segments.  This is
useful if you want to apply and combine a series of clips into on,
then execute a filter (e.g. change volume, flip, crop, etc.) against
the combination of that series.

The default action to commit against a group is to concatenate each clip
serially.  Optionally, you can provide a C<c> option (e.g. C<{/c> ) to
the brace, but this is the default action and unnecessary.

=cut

$M{'group:concat'}='{/?c?';
$F{'group:concat'}=sub {
	my($node)=@_;
	my($count)=0;
	my(@inputs)=();
	my(@concat)=();

	&copykeys($node->{'tree'}[0] => $node, 'width', 'height', 'fps');

	foreach my $child (@{$node->{'tree'}}) {
		push(@inputs, $child->{'video'}, $child->{'audio'});
		$count++;
	}

	if($count==1) {
		&copykeys($node->{'tree'}[0] => $node, 'video', 'audio', 'fps');
	} else {
		($node->{'video'}, $node->{'audio'})=&next_labels($node);

		push(@concat, &fmt('#{Is}concat=n=#{N}:v=#{V}:a=#{A}#{Ov}#{Oa}', {
				'Is'	=> join('', @inputs),
				'N'	=> $count,
				'V'	=> 1,
				'A'	=> 1,
				'Ov'	=> $node->{'video'},
				'Oa'	=> $node->{'audio'},
			}));
	}

	return(@concat);
};

=item {[/]<h|v> <...> }

Create grouped segments stacked in a parallel fashion.  Use this syntax
to combine multiple files by either stacking them horizontally with C<hstack>,
vertically with C<vstack>.  All operations outside the braces will be applied
to the combined video against it's new resolution.

Stack notes:
the duration of the combination is based on the shortest sub entry.
What goes inside the braces follows all other conventions for file
inputs and command-line tokens.

=cut

$M{'group:stack'}='{/?([hv])';
$F{'group:stack'}=sub {
	my($node, $type)=@_;
	my(@vin)=();
	my(@ain)=();
	my(@stack)=();

	foreach my $sub (@{$node->{'tree'}}) {
		push(@vin, $sub->{'video'});
		push(@ain, $sub->{'audio'});
	}

	&copykeys($node->{'tree'}[0] => $node, 'width', 'height', 'fps');
	if($type eq 'h') {
		$node->{'width'}=List::Util::sum(
			map($_->{'width'}, @{$node->{'tree'}})
		);
	} elsif($type eq 'v') {
		$node->{'height'}=List::Util::sum(
			map($_->{'height'}, @{$node->{'tree'}})
		);
	} else {
		&err(9, 'Stack', $type, 'not known.');
	}

	($node->{'video'}, $node->{'audio'})=&next_labels($node);

	push(@stack, &fmt('#{Is}#{T}stack=inputs=#{N}:#{D}=1#{O}', {
			'Is'	=> join('', @vin),
			'T'	=> $type,
			'N'	=> scalar(@vin),
			'D'	=> 'shortest',
			'O'	=> $node->{'video'},
		}));
	push(@stack, &fmt('#{Is}amix=inputs=#{N}:duration=#{D}#{O}', {
			'Is'	=> join('', @ain),
			'N'	=> scalar(@ain),
			'D'	=> 'shortest',
			'O'	=> $node->{'audio'}
		}));

	return(@stack);
};

=item {[/]<a> <...> }

Create a group which has one video file (if multiple, the first one is
used) and additional audio files.  The audio files are overlayed together
with the audio track from the video to produce a new video file with
multiple audio tracks.  The audio tracks are integrated together
using the L<ffmpeg-filters(1)> C<amix> filter and the length of the
segment will be the length of the video clip.  If any audio files are
shorter, they will end early and if they are longer, they will be clipped
to length.

If C<volume>, C<denoise>, etc. filters need to be applied specificly to
input audio clips, perform those actions by placing the tokens directly
before the clip token.  This allows for easy and specific adjustment.  Any
audio filters which should be applied to the full, resulting audio tracks
should be placed outside the grouping braces.

Note, to not confuse B<clips> it is recommended to place an C<audio> token
before any video files you wish to be used for audio only, ensuring
B<clips> knows to consider them audio tracks and not accidentially use
them as the video source.  The first video track found will be the one
used as the video track.

=cut

$M{'group:aoverlay'}='{/?a';
$F{'group:aoverlay'}=sub {
	my($node)=@_;
	my($vout, $aout)=&next_labels($node);
	my(@ain)=();

	&copykeys($node->{'tree'}[0] => $node, 'video', 'width', 'height', 'fps');
	$node->{'audio'}=$aout;

	foreach my $child (@{$node->{'tree'}}) {
		push(@ain, $child->{'audio'});
	}

	return(&fmt('#{Is}amix=inputs=#{N}:duration=#{D}#{O}', {
			'Is'	=> join('', @ain),
			'N'	=> scalar(@ain),
			'D'	=> 'first',
			'O'	=> $node->{'audio'},
		}));
};

=item ffmpeg/<v|a>/<filter>

THERE BE DRAGONS HERE!  This token probably should not exist, and it is likely
you will cause ffmpeg to exit with error when using it by making a simple
mistake.  This token allows you to enter a simple filtergraph video or audio
filter that would be supported by the L<ffmpeg(1)> C<-filter:a> or
C<-filter:v>  (aka C<-af> or C<-vf>) command-line options which are suitable
for a comma (,) chain.  These filters take a single stream as input and
produce a single stream as output.  Look for the term "simple filtergraph"
in the L<ffmpeg(1)> manual for more information.

This filter runs after other video or audio simple filtergraphs.

Note, if you use this token often, consider using a L<UserFile> instead
(see below).

=cut

$M{'simple:video:ffmpeg'}='ff[mpeg]*/v/(.*)';
$F{'simple:video:ffmpeg'}=sub {
	#Wait, what.  We are passing this straight through to ffmpeg?  Scary!
	return($_[1]);
};

$M{'simple:audio:ffmpeg'}='ff[mpeg]*/a/(.*)';
$F{'simple:audio:ffmpeg'}=sub {
	#Wait, what.  We are passing this straight through to ffmpeg?  Scary!
	return($_[1]);
};

=item <time>-<time>

This is the clip you want incorporated into the video.  An example would be
C<0:03.300-0:14.963> for an approximately 11 second clip.  Please note that
if you specify a transition between clips, that you will lose fidelity on
both video and audio during the transition time.  If you are trying to
capture a sound or image and also want transitions, please make sure to
make the clip long enough buffer from your critical content.

=item <time>-

A special form of the clip specification that goes until the end of the
video file.  There is no analogous form for the start of a file, but you
can just specify C<0-> to start at 0 seconds.

=back

=cut

=head2 Processing Order

Filters are applied using a specific order, regardless of where they were
placed on the command-line prior to a clip or group.  To display this order,
run C<clips -print=order>.

=cut

my(@ORDER)=qw(
	group:stack
	group:concat
	group:aoverlay
	complex:audio
	complex:overlay
	complex:transition
	complex:fade
	complex:blur
	complex:speed
	simple:audio:denoise
	simple:audio:normalize
	simple:audio:volume
	simple:audio:delay
	simple:audio:ffmpeg
	simple:video:fps
	simple:video:text
	simple:video:crop
	simple:video:scale
	simple:video:flip
	simple:video:ffmpeg
);

=head2 Extending Functionality with a UserFile

A file can be supplied which contains extensions to B<clips> capabilities.
This functionality can be thought of like creating macros or aliases
for commonly used or interesting effects in lieu of using the C<-ffmpeg>
command-line token.  The processing order is that user extenstions are
processed after built-in filters, and in the order in which they are defined
in the F<UserFile>.

=head3 UserFile syntax

All non-blank lines not matching the following will cause errors:

        <#|;|//>[Comment text]
        user:<audio|video>:<name>  <token>[/X=a][...]  <filtername>[=options]
	   user:transition:<key>      <xfade transition name>

What this will do is create a simple audio or video filter type named C<token>.
Optionally, C<token> can have options which are specified after.  These options
can have default values (in case not present) and those are specified after
an equal (=) symbol.  After that comes the L<ffmpeg-filters(1)> filter that
should be invoked in it's entirety.  Options (e.g. C<X>) above can be used
in the definition using the syntax C<#{X}> within the definiton.

Note, B<clips> provides following built-in macros which can be used within
any user definition:

=over 8

=item _W

This stores the width of the current stream (assuming it is a video stream).

=item _H

This stores the height of the current stream (assuming it is a video stream).

=item _L

This stores the length, in seconds, of the current stream.

=item _F

This stores the frames/second (aka frame rate) of the file as a floating-point
number.

=back

=head4 Example

        # This is a comment about my awesome filters

        user:audio:cave    cave/D=1000    aecho=0.5:0.4:#{D}:0.5
        user:audio:speech  speech/N       afftdn=nf=#{N},dialoguenhance,\
                                          volume=2
        user:video:bblur   bblur/X=5/Y=5  avgblur=sizeX=#{X}:sizeY=#{Y}

        user:transition:l  wipeleft

In this example, if a person specifies the token C<cave> the audio filter
C<aecho=0.5:0.4:1000:0.5> will be applied to the next clip.  If they specify
C<cave/2000> then the audio filter C<aecho=0.5:0.4:2000:0.5> will be applied
to the next clip.  For the speech token, you can see that multiple filters
are applied all as part of one token.  This can be called like C<speech/-25>,
but if you try to call just C<speech> it will error because (without a default)
the parameter is mandatory.  C<speech> calls three filters, and they are
defined across 2 lines with the help of the backslash (\) character at the
end of the first line.  In the third example, two options are allowed
and each have a default.  So, C<bblur/10/12> will blur with C<X=10> and C<Y=12>.
But, C<bblur/10> will set C<X=10> and leave C<Y=5>, whereas C<bblur//10> will
leave C<X=5> and set C<Y=10>.  This is all a little funky, but it's a simple
macro language and so you have to forgive it's quirks.

Lastly, if someone were to now place C</l> between two clips, the transition
between the two would use the C<xfade> filter's, see L<ffmpeg-filters(1)>,
C<wipeleft> transition effect.  Any re-use of one of the default/built-in
shortcut keys will override the default behavior.  Note that technically,
these transition keys can be more than one letter, so you could use
cl, cr, ... for cover left, right, ...; sl, sr, ... for slide left, etc;
wl, wr, ... for wipe left, ...; and so on if you wanted shortcuts for
all the different styles.

=cut

sub ltrim {
	my($s)=@_;
	$s=~s/^\s*//;
	return($s);
}

sub read_user_file {
	my($file)=@_;
	my($CONF)=IO::Handle->new;
	my($id, $match, $macro);
	local($_);

	print "User Config:\n" if($ARG{'debug'}>5);

	open($CONF, '<', $file);
	while(<$CONF>) {
		next if(m|^\s*[#;/].*$|);
		next if(m|^\s*$|);

		if(s/\\\s*$//) {
			$_.=&ltrim(scalar <$CONF>);
			redo;
		}

		if(m|^user:transition:(\w+)\s+(\w+)|) {
			$TRANSITION{$1}=$2;
			if($ARG{'debug'}>5) {
				printf(" User transition: %3s = %s\n\n", $1, $2);
			}
		} elsif(m|^(user:[videoau]+:\w+)\s+(\w+)/?(\S*)\s+(.+)$|i) {
			($id, $name, $opts, $macro)=@{^CAPTURE};

			push(@ORDER, $id);
			$UM{$id}=$name;
			$UF{$id}=[$opts, $macro];

			if($ARG{'debug'}>5) {
				printf(" User filter (%s) '%s', parameters: %s\n > %s\n\n",
					$id, $name, $opts||'NONE', $macro);
			}
		} else {
			&err(11, 'User file syntax error:', $_);
		}
	}
	print "\n" if($ARG{'debug'}>5);
	close($CONF);
}

=head4 User Filter Execution

Simple user filters can be run multiple times like other simple filters.
Since these are user defined, the effects of doing so are entirely on
you.  The process of running them is a very simple macro expantion/substitution
of the arguments supplied on the command-line token into the definition
string, and then it is added to the audio or video stream as appropriate.
Arguments must be in the exact same order as they are listed in the
definition.  If you want to keep the default value, you can skip the
parameter by leaving it empty, but you still need to provide the slash (/)
delimeter.

=cut

sub run_simple_user {
	my($node, $id, @args)=@_;
	my(@params)=split(m|/|, $UF{$id}[0]);
	my(@keys)=();
	my($map)={
		'_W'	=> $node->{'width'},
		'_H'	=> $node->{'height'},
		'_L'	=> $node->{'length'},
		'_F'	=> $node->{'fps'},
	};

	foreach my $param (@params) {
		if($param=~m/^(\w+)=(.*)$/) {
			$map->{$1}=$2;
			push(@keys, $1);
		} elsif($param=~m/^(\w+)$/) {
			$map->{$1}=undef;
			push(@keys, $1);
		} else {
			&err(11, 'User filter definition not understood:', $param);
		}
	}

	while(@args) {
		if(length($args[0])>0) {
			$map->{shift(@keys)}=shift(@args);
		} else {
			shift(@keys);
			shift(@args);
		}
	}

	foreach my $key (keys(%$map)) {
		unless(defined($map->{$key})) {
			&err(11, $id, '- key', $key,
				"not provided and doesn't have a default:\n ", $UF{$id}[1]);
		}
	}

	return(&fmt($UF{$id}[1], $map));
}

=head2 Parsing Structure

B<clips> is essentially a 2 pass compiler.  In the first pass, it tokenizes
the command-line and creates a tree-like execution structure for the commands
provided.  In this pass, unary, binary (e.g. C</> and C<%>), and matching
(e.g. C<{> and C<}> operators are inserted into the tree and it's data is
enhanced using all of the information found throughout the command-line.

In the second pass, that tree is turned into an executable L<ffmpeg(1)>
command which can be run.  Each node in the tree is examined to determine
which actions are taken, assign video streams as appropriate, and
implement the filters to make each stage happen.  The tree is parsed in
a depth-first fashion, culminating with the root node being the final
stiching together of the output video.

=cut

my($I)=0;
sub node {
	my($i)=$I++;
	my($node)={
		'type'	=> 'root',
		'length'	=> 0,
		'index'	=> $i,
		'step'	=> 0,
		'tree'	=> [],
		'timer'	=> 'sum',
		'video'	=> undef,
		'audio'	=> undef,
		'f:v'	=> '',
		'f:a'	=> '',
		'f:x'	=> '',
		@_
	};

	return($node);
}

sub insert_branch {
	my($leaf, $branch)=@_;
	my($trunk)=$leaf->{'parent'};
	my(@attrs)=qw(parent video audio width height fps);

	&copykeys($leaf => $branch, @attrs);

	#N.B. the leaf is expected to be plucked from the trunk prior to call
	push(@{$trunk->{'tree'}}, $branch);
	push(@{$branch->{'tree'}}, $leaf);
	return($leaf->{'parent'}=$branch);
}

sub next_labels {
	my($node, %opt)=@_;
	my($i, $s)=(\$node->{'index'}, \$node->{'step'});
	my(@labels)=();

	if(%opt) {
		if(exists($opt{'video'})) {
			if(defined($opt{'video'})) {
				while($opt{'video'}>0) {
					push(@labels, &fmt('[v%d.%d]', $$i, $$s++));
					$opt{'video'}--;
				}
			} else {
				push(@labels, &fmt('[v%d.%d]', $$i, $$s++));
			}
		}
		if(exists($opt{'audio'})) {
			if(defined($opt{'audio'})) {
				while($opt{'audio'}>0) {
					push(@labels, &fmt('[a%d.%d]', $$i, $$s++));
					$opt{'audio'}--;
				}
			} else {
				push(@labels, &fmt('[a%d.%d]', $$i, $$s++));
			}
		}
	} else {
		push(@labels,
			&fmt('[v%d.%d]', $$i, $$s), &fmt('[a%d.%d]', $$i, $$s));
		$$s++;
	}

	return(@labels);
}

#Note: 'complex' filters should be given their own node in the tree.

sub parse {
	my($root)=&node(
		'type'			=> 'root',
		'group:concat'		=> [],
	);
	my($cur)=$root;
	my(%filt)=();
	my($src)=undef;
	my($stream)=0;
	my(@tokens)=();
	my(@args);

	foreach(@_) {			#Pre-processor
		s/^\s+//;
		s/\s+$//;

		if(m|^}}+|) {
			for(my $i=0; $i<length($_); $i++) {
				push(@tokens, '}');
			}
		} elsif(m|^\[(\d)(:[av])?\]\s*(.*)$|i) {
			if($ARG{$1}) {
				push(@tokens, $ARG{$1});
			} else {
				&err(12, "A placeholder was used without a reference:",
					"'[$1]' has no corresponding '-$1'");
			}
			push(@tokens, 'audio') if(lc($2) eq ':a');
			push(@tokens, 'volume/0') if(lc($2) eq ':v');
			push(@tokens, $3) if($3);
		} else {
			push(@tokens, $_);
		}
	}
	print "Tokens:\n '", join("' '", @tokens), "'\n\n" if($ARG{'debug'}>2);

	foreach(@tokens) {		#Processor
		if(-f $_) {
			$src=$_;
			$SOURCES{$src}={
				'length'	=> FFUtils::duration($src),
				'width'	=> FFUtils::width($src),
				'height'	=> FFUtils::height($src),
				'fps'	=> FFUtils::framerate($src),
				'video'	=> FFUtils::has_video($src),
				'audio'	=> FFUtils::has_audio($src),
			};
		} elsif(@args=m|^$M{'complex:fade'}|i) {
			my($node)=&node(
				'type'			=> 'complex',
				'parent'			=> $cur,
				'complex:fade'		=> [ @args ],
			);

			if($args[0]=~m/out/i) {
				my($last)=pop(@{$cur->{'tree'}}) || &err(7,
					'fadeout is a postfix operator (after a clip).');
				$cur=&insert_branch($last => $node)->{'parent'};
			} else {
				push(@{$cur->{'tree'}}, $node);
				$cur=$node;
			}

			#Filters aren't applied here, forcing them down to the child
		} elsif(@args=m|^$M{'complex:blur'}|i) {
			my($node)=&node(
				'type'			=> 'complex',
				'parent'			=> $cur,
				'complex:blur'		=> [ @args ],
			);

			if($args[0]=~m/out/i) {
				my($last)=pop(@{$cur->{'tree'}}) || &err(7,
					'blurout is a postfix operator (after a clip).');
				$cur=&insert_branch($last => $node)->{'parent'};
			} else {
				push(@{$cur->{'tree'}}, $node);
				$cur=$node;
			}

			#Filters aren't applied here, forcing them down to the child
		} elsif(@args=m|^$M{'complex:transition'}|i) {	#Binary operator
			my($last)=pop(@{$cur->{'tree'}}) ||
				&err(7, 'Cannot transition from nothing.');
			my($node)=&node(
				'type'			=> 'complex',
				'length'			=> -($args[0] || $ARG{'transition'}),

				%filt,
				
				'complex:transition'	=> [
								$args[0] || $ARG{'transition'},
								$args[1] || $ARG{'transition-type'},
							],
			);

			$cur=&insert_branch($last => $node);

			%filt=();
		} elsif(@args=m|^$M{'complex:overlay'}|i) {	#Binary operator
			my($last)=pop(@{$cur->{'tree'}}) ||
				&err(7, 'Cannot overlay nothing.');
			my($node)=&node(
				'type'			=> 'complex',
				'tree'			=> [],
				'timer'			=> 'first',

				%filt,

				'complex:overlay'	=> [ $args[0] || $ARG{'overlay'} ],
			);

			$cur=&insert_branch($last => $node);

			%filt=();
		} elsif(@args=m|^$M{'group:aoverlay'}|i) {
			my($node)=&node(
				'type'			=> 'group',
				'parent'			=> $cur,
				'merge'			=> 'a',
				'timer'			=> 'first',
				'group:aoverlay'	=> [],

				%filt,
			);

			push(@{$cur->{'tree'}}, $node);
			$cur=$node;

			%filt=();
		} elsif(@args=m|^$M{'group:stack'}|i) {
			my($type)=lc($args[0]);
			my($node)=&node(
				'type'			=> 'group',
				'parent'			=> $cur,
				'merge'			=> $type,
				'timer'			=> 'shortest',
				'group:stack'		=> [ $type ],

				%filt,
			);

			push(@{$cur->{'tree'}}, $node);
			$cur=$node;

			%filt=();
		} elsif(@args=m|^$M{'group:concat'}|i) {
			my($node)=&node(
				'type'			=> 'group',
				'parent'			=> $cur,
				'merge'			=> 'c',
				'group:concat'		=> [],

				%filt,
			);

			push(@{$cur->{'tree'}}, $node);
			$cur=$node;

			%filt=();
		} elsif(m|^}|i) {					 #pop out of group
			unless($cur->{'type'} eq 'group') {
				&err(4, "Syntax error closing a group that doesn't exist.");
			}

			if(%filt) {
				&err(4, 'Filter tokens are missing a clip:', keys(%filt));
			}

			#Place the first video file first to help compute length:
			if($cur->{'merge'} eq 'a') {
				for(my $i=0; $i<@{$cur->{'tree'}}; $i++) {
					if($cur->{'tree'}[$i]{'complex:audio'}) {
						next;
					}
					if($cur->{'tree'}[$i]{'type'} eq 'complex') {
						unshift(@{$cur->{'tree'}},
							splice(@{$cur->{'tree'}}, $i, 1));
						last;
					}
					if($SOURCES{$cur->{'tree'}[$i]{'file'}}{'video'}) {
						unshift(@{$cur->{'tree'}},
							splice(@{$cur->{'tree'}}, $i, 1));
						last;
					}
				}
			}

			while($cur->{'type'} eq 'complex') { #bubble out
				$cur=$cur->{'parent'};
			}
			if($cur->{'type'} eq 'group') {
				$cur=$cur->{'parent'};
			} else {
				&err(98, 'Tree structure is invalid.');
			}
			while($cur->{'type'} eq 'complex') { #bubble out
				$cur=$cur->{'parent'};
			}

			redo if(s|^}}|}|);  #If someone bundles braces, make it work

		} elsif(m/^([\d:.]+)-([\d:.]+)?$/) {
			my($start)=FFUtils::time2secs($1);
			my($end)=defined($2)?FFUtils::time2secs($2):$SOURCES{$src}{'length'};
			my($node)=&node(
				'type'			=> 'clip',
				'parent'			=> $cur,
				'file'			=> $src,
				'start'			=> $start,
				'end'			=> $end,
				'length'			=> $end-$start,

				%filt,
			);

			unless($src) {
				&err(2, 'An input file must be specified.');
			}

			if($SOURCES{$src}{'video'}) {
				$node->{'video'}=&fmt('[%d:v]', $stream);
				$node->{'width'}=$SOURCES{$src}{'width'};
				$node->{'height'}=$SOURCES{$src}{'height'};
				$node->{'fps'}=$SOURCES{$src}{'fps'};
			} else {
				$node->{'width'}=0;
				$node->{'height'}=0;
			}

			if($SOURCES{$src}{'audio'}) {
				$node->{'audio'}=&fmt('[%d:a]', $stream);
			}

			if($ARG{'normalize'}) {
				$node->{'simple:audio:normalize'}=[];
			}

			if($ARG{'practice'}) {
				$node->{'simple:video:fps'}=[$ARG{'rate'}];
				$node->{'simple:video:scale'}=[$ARG{'resolution'}];
			}

			if($ARG{'audio-only'}) {
				push(@INPUTS, '-r', $ARG{'rate'});
			}
			push(@INPUTS, '-ss', $start, '-to', $end, '-i', $src);
			push(@WATCH, '--{', "-start=$start", "-end=$end", $src, '--}');

			if($end > $SOURCES{$src}{'length'}) {
				&err(3, "'$2' is past the end of $src.");
			}

			if($cur->{'type'} eq 'group' && $cur->{'merge'} ne 'a' && !$node->{'simple:video:scale'}) {
				push(@{$node->{'simple:video:scale'}}, []);
			}

			push(@{$cur->{'tree'}}, $node);
			while($cur->{'type'} eq 'complex') { #bubble out
				$cur=$cur->{'parent'};
			}

			$stream++;

			%filt=();
		} else {
			my($found)=0;

			foreach my $complex (grep(m/^complex:/, @ORDER)) {
				if(@args=m|^$M{$complex}|i) {
					my($node)=&node(
						'type'		=> 'complex',
						'parent'		=> $cur,
						$complex		=> [ @args ],
					);

					push(@{$cur->{'tree'}}, $node);
					$cur=$node;

					$found=1;
				}
			}

			foreach my $simple (grep(m/^simple:/, @ORDER)) {
				if(@args=m|^$M{$simple}|i) {
					push(@{$filt{$simple}}, [ @args ]);
					$found=1;
				}
			}

			foreach my $user (grep(m/^user:/, @ORDER)) {
				if(m|^$UM{$user}/?(.*)$|) {
					push(@{$filt{$user}}, [ split(m|/|, $1) ]);
					$found=1;
				}
			}

			unless($found) {
				&err(1, "'$_' not understood, or file does not exist.");
			}
		}
	}

	if($cur->{'type'} eq 'group') {
		&err(4, 'A Matching group parenthesis is missing');
	}
	if($cur->{'type'} ne 'root') {
		&err(100, "Unknown error: the tree didn't end up back at the root");
	}
	if(%filt) {
		&err(4, 'Filter tokens are missing a clip:', keys(%filt));
	}

	return($root);
}

sub compute_lengths {
	my($node)=@_;
	my($time)=$node->{'length'};
	my(@lengths)=();

	foreach my $child (@{$node->{'tree'}}) {
		push(@lengths, &compute_lengths($child));
	}

	if($node->{'timer'} eq 'shortest') {
		$time+=List::Util::min(@lengths);
	} elsif($node->{'timer'} eq 'longest') {
		$time+=List::Util::max(@lengths);
	} elsif($node->{'timer'} eq 'first') {
		$time+=$lengths[0];
	} elsif($node->{'timer'} eq 'last') {
		$time+=$lengths[-1];
	} else {
		$time+=List::Util::sum(@lengths);
	}

	if(exists($node->{'complex:speed'})) {
		$time=$time/$node->{'complex:speed'}[0];
	}

	return($node->{'length'}=$time);
}

sub generate_filters {
	my($node)=@_;
	my(@audio)=();
	my(@video)=();
	my(@filters)=();
	my(@complex)=();
	my($vout, $aout)=&next_labels($node);

	foreach my $child (@{$node->{'tree'}}) {
		push(@filters, &generate_filters($child));
	}

	foreach my $filter (@ORDER) {
		if($filter=~m|simple:audio| && exists($node->{$filter})) {
			if(ref($node->{$filter}[0]) eq 'ARRAY') {
				foreach my $run (@{$node->{$filter}}) {
					push(@audio, $F{$filter}->($node, @$run));
				}
			} else {
				push(@audio, $F{$filter}->($node, @{$node->{$filter}}));
			}
		} elsif($filter=~m|simple:video| && exists($node->{$filter})) {
			if(ref($node->{$filter}[0]) eq 'ARRAY') {
				foreach my $run (@{$node->{$filter}}) {
					push(@video, $F{$filter}->($node, @$run));
				}
			} else {
				push(@video, $F{$filter}->($node, @{$node->{$filter}}));
			}
		} elsif($filter=~m|user:audio| && exists($node->{$filter})) {
			if(ref($node->{$filter}[0]) eq 'ARRAY') {
				foreach my $run (@{$node->{$filter}}) {
					push(@audio, &run_simple_user($node, $filter, @$run));
				}
			} else {
				push(@audio, $F{$filter}->($node, @{$node->{$filter}}));
			}
		} elsif($filter=~m|user:video| && exists($node->{$filter})) {
			if(ref($node->{$filter}[0]) eq 'ARRAY') {
				foreach my $run (@{$node->{$filter}}) {
					push(@video, &run_simple_user($node, $filter, @$run));
				}
			} else {
				push(@video, $F{$filter}->($node, @{$node->{$filter}}));
			}
		} elsif(exists($node->{$filter})) {
			#Complex filters should have their own node, no multi
			push(@complex, $F{$filter}->($node, @{$node->{$filter}}));
		}
	}

	if(@complex) {
		$node->{'f:x'}=join(';', @complex);
		push(@filters, $node->{'f:x'});
	}
	if(@video) {
		unless($node->{'video'}) {
			$node->{'video'}=$node->{'tree'}[0]{'video'};
		}

		$node->{'f:v'}=$node->{'video'} . join(',', @video) . $vout;
		push(@filters, $node->{'f:v'});
		$node->{'video'}=$vout;
	}
	if(@audio) {
		unless($node->{'audio'}) {
			$node->{'audio'}=$node->{'tree'}[0]{'audio'};
		}

		$node->{'f:a'}=$node->{'audio'} . join(',', @audio) . $aout;
		push(@filters, $node->{'f:a'});
		$node->{'audio'}=$aout;
	}

	return(@filters);
}

sub map_outputs {
	my($root)=@_;
	my(@program)=();
	my(@filters)=&generate_filters($root);

	if(@filters) {
		push(@program, '-filter_complex', join(';', @filters));
	}

	if($root->{'video'}=~s/\[(\d+):v\]/$1:v/) {
		push(@program, '-c:v', 'copy');
	}
	if($root->{'audio'}=~s/\[(\d+):a\]/$1:a/) {
		push(@program, '-c:a', 'copy');
	}

	push(@program, '-map', $root->{'video'});
	if($ARG{'audio-only'}) {
		($JFH, $JUNK)=File::Temp::tempfile(SUFFIX => '.mp4');
		push(@program, $JUNK);
	}
	push(@program, '-map', $root->{'audio'});

	return(@program);
}

sub tag {
	return('-metadata', &fmt('%s=%s', @_));
}

=head2 Execution

If you are running in the C<-dry-run> mode, then all B<clips> will do is
print out what it would have done, and exit.  Similarly, if you requested
help with C<-h> or C<-help> or any of the other informational command-line
options, then the correct information will be displayed before exiting
without processing any video files.

=cut

if($ARG{'version'}) {
	print "$0 $VERSION\n";
	exit(0);
} elsif($ARG{'help'} || $ARG{'print'}=~m/usage/i) {
	pod2usage(-verbose => 1, -exitval => 0);
} elsif($ARG{'examples'} || $ARG{'print'}=~m/example/i) {
	pod2usage(-verbose => 99, -sections => 'EXAMPLES', -exitval => 0);
} elsif($ARG{'manual'} || $ARG{'print'}=~m/help/i) {
	pod2usage(-verbose => 2, -exitval => 0);
} elsif($ARG{'dry-run'}) {
	print "<DRY-RUN>\n";
}

=pod

Otherwise, B<clips> will carefully construct an L<ffmpeg(1)> program after
parsing the tokens provided on the command-line.  Filters, resolutions,
frame rates, tags, etc. will all be combined as described above to prepare
this program for execution.

=cut

&read_user_file($ARG{'userfile'}) if($ARG{'userfile'});

if($ARG{'print'}=~m/order/i || $ARG{'debug'}>3) {
	print "Execution Order:\n ";
	print join("\n ", @ORDER), "\n";
	if($ARG{'print'}=~m/order/i) {
		exit(0);
	} else {
		print "\n";
	}
}

if($ARG{'print'}=~m/transition/i || $ARG{'debug'}>4) {
	print "Transition Shortcut Keys:\n";
	foreach my $key (sort(keys(%TRANSITION))) {
		printf("%3s = %s\n", $key, $TRANSITION{$key});
	}
	if($ARG{'print'}=~m/transition/i) {
		exit(0);
	} else {
		print "\n";
	}
}

if($ARG{'print'}=~m/font/i) {
	&print_fonts($ARG{'font'});
	exit(0);
}

$ROOT=&parse(@ARGV);
&compute_lengths($ROOT);

push(@FFPROGRAM, &map_outputs($ROOT));
push(@FFPROGRAM, '-s', $ARG{'resolution'})			if($ARG{'resolution'});
push(@FFPROGRAM, '-r', $ARG{'rate'})				if($ARG{'rate'});
push(@FFPROGRAM, '-to', $ARG{'end'})				if($ARG{'end'});
push(@FFPROGRAM, &tag('title', $ARG{'title'}))		if($ARG{'title'});
push(@FFPROGRAM, &tag('comment', $ARG{'comment'}))	if($ARG{'comment'});
push(@FFPROGRAM, &tag('description', $ARG{'description'}))	if($ARG{'description'});

if($ARG{'ffmpeg'}) {
	foreach my $passthrough (@{$ARG{'ffmpeg'}}) {
		push(@FFPROGRAM, split(m/\s+/, $passthrough));
	}
}

=pod

If informational settings are applied
(e.g. debugging level 3 or C<-print=tree> then a full dump of the data
structure created from parsing the command-line will be displayed before
execution.

=cut

if($ARG{'debug'}>2) {
	&treedump;
} elsif($ARG{'print'}=~m/tree/i) {
	&treedump;
	exit(0);
}

=pod

Once the L<ffmpeg(1)> command-line is fully assembled and ready for execution,
it is executed.  Pro tip, use the C<-d> or C<-debug> command-line options
to have that command displayed to the screen.  It is useful for education,
debugging your video, and tweaking the command-line when something goes wrong.

Please note that B<clips> will always automatically overwrite exist files.
It does, however, display a message of this intention and waits 3 seconds
before starting.  If you think you made a mistake, C<CTRL-C> is your friend
here!

Creating a video file can take a long time, and so a status line showing
progress and estimated time to completion will show on the terminal.  Please
note that early estimations of time are a litle bit inaccurate, but you will
see the time become more realistic as you process more of the file.

If the first parameter (the output file) is specified as C<-> then
L<mpv(1)> will be started to show the source clips used to create
the video.  Note that none of the filters are applied, and so this
is only partially useful.

=cut

if($DST=~m/^(mpv|preview|watch|-)$/i) {
	if($ARG{'dry-run'}) {
		print join(' ', @MPV, @WATCH), "\n";
	} else {
		system(@MPV, @WATCH);
		print "\n";
	}
} else {
	if($ARG{'dry-run'} || $ARG{'debug'}) {
		print "\n", FFUtils::cmdline(@INPUTS, @FFPROGRAM, $DST), "\n\n";
	} elsif($ARG{'print'}=~m/command/i) {
		print FFUtils::cmdline(@INPUTS, @FFPROGRAM, $DST), "\n";
		exit(0);
	}

	if($ARG{'dry-run'}) {
		print "\nN.B. '$DST' exists and will be overwritten\n" if(-r $DST);
	} else {
		FFUtils::status(
			FFUtils::ffmpeg(@INPUTS, @FFPROGRAM, $DST),
			$ROOT->{'length'}
		);
	}

	if($?) {
		printf(STDERR "ffmpeg exited with errors (exit value: %d).\n", $?>>8);
	} else {
		printf("\nOutput file:\n'%s' (%s)\n", $DST,
			FFUtils::secs2time($ROOT->{'length'}));
	}
}

if($ARG{'dry-run'}) {
	print "</DRY-RUN>\n";
}

=head1 ENVIRONMENT

=over 8

=item CLIPS_USERFILE

If set, this environment variable should reference a configuration
file location for user defined tokens.  See
L<Extending Functionality with a UserFile> above.

=back

=head1 NOTES

There is an audio only C<-A> or C<-audio-only> option to running B<clips>
even with video files.  It's worth noting that, to ensure all filters work
properly (including complex ones) that B<clips> actually produces an
entirely pathetic video file at less than one frame per second.  Then,
promptly deletes that file before exiting.  This ensures that everything
works, but is fast because of the absurdly, otherwise unusable, tiny
frame rate.

=cut

if($ARG{'audio-only'}) {
	close($JFH);
	unlink($JUNK);
}

=pod

Use C<mpv --osd-fractions> (or an equivalent) to show exact frame time
specifications for finding the best offsets.  B<clips> can use fractional
time formats to ensure the exact frame cut can be specified on the command
line.  Any time format mentioned under B<Time duration> in L<ffmpeg-utils(1)>
is supported.

=head1 EXAMPLES

=over 8

=item clips new.mp4 src1.mp4 0:00.0-3:20.2 4:01.0-5:50.3 src2.mp4 0:00-

Create F<new.mp4> from 2 clips of src1.mp4 followed by the entirety of src2.mp4

=item clips output.mp4 video.mp4 fadein/2 0:20.369-1:46.900 fadeout

Make F<output.mp4> from a 1 minute and 26 second clip of F<video.mp4> with
the a fadein of 2 seconds and the default fadeout of 3 seconds.

=item clips out.mp4 in.mp4 0:00-39.060 / 1:22.800-2:03.240

Create f<out.mp4> from 2 sections of F<in.mp4> with the default transition
type of C<fade> and default time of 0.8 seconds.

=item clips new.mp4 vid1.mp4 0- /1.4/U vid2.mp4 0-

Create F<new.mp4> from all of F<vid1.mp4> and F<vid2.mp4> with a swipe up
style transition of 1.4 seconds.

=item clips new.mp4 source.mp4 0:13-0:44 /2 1:14-2:33 /2 4:11-5:01

Create a file F<new.mp4> with 3 clips from F<source.mp4> all using a
2 second fade transition.

=item clips -g 1920:1080 new.mp4 intro.mp4 0- { left.mp4 0:19.600- right.mp4 0- } outro.mp4 0-0:34.369 /0.5 0:38.900-

Create F<new.mp4> by using an intro file, then having a segment consisting
of the two files F<left.mp4> and F<right.mp4> stacked horizontally.  Finish
off with two clips from the file F<outro.mp4>.

=item clips new.mp4 base.mp4 0-0:30 %70/lime:0.02:0.03 top.mp4 0-0:30

This will create a 30 second clip of top.mp4 layed over base.mp4 in a way
that it is completely transparent for lime and very nearly lime colors,
and slightly transparent for the rest of he colors.

=item clips new.mp4 file.mp4 ffmpeg/v/unsharp=7:7:-2:7:7:-2 0:10-3:45

Write F<new.mp4> from the 10 seconds until 3 minutes, 45 seconds
portion of F<file.mp4>.  Use the L<ffmpeg-filters(1)> filter C<unsharp>
as a simple video filtergraph.  C<unsharp> is not defined inside of
C<clips>, but this filter will be passed through to L<ffmpeg(1)> exactly
as defined here.

=item clips wide.mp4 phone.mp4 fade-in {/h
        crop/420:1080:1:-200 flip ffmpeg/v/gblur=40 0:12.727-2:04.265
	   crop/1080:1080:0:-200 0:12.727-2:04.265
	   crop/420:1080:-1:-200 flip ffmpeg/v/gblur=40 0:12.727-2:04.265
	 } fade-out

Take a 1080x1920 vertical phone image, crop out the 1080x1080 section to
keep, and suround it by blurred mirrors of the video content.  For extra
fun, we could have added an C<ffmpeg/v/eq=brightness=-0.4> to darken the
blurred sides.

=item clips carousel.mp4 src1.mp4 0-10 /10/L src2.mp4 0-10 /10/L
      src3.mp4 0-10 /10/L src4.mp4 0-10 /10/L src1.mp4 10-20 /10/L
	 src2.mp4 10-20 /10/L src3.mp4 0-20 /10/L src4.mp4 10-15 

Create a continuously scrolling video of 10 second clips from 4 different
input files moving from right to left.  After the last video scrolls to
cover the entire window, the video ends.

=back

=head1 BUGS

Input files have to be compatible.  B<clips> doesn't do very much at all,
when multiple input files are used, to make sure files are compatible.  You
can use the C<-resolution> command-line option to force videos into line,
but be careful to review the results.

This is more of an L<ffmpeg(1)> bug, but if find transitions that stutter,
shutter, or hang, then it might be the frame rate.  Before trying anything
else, use he C<-R> or C<-rate> command-line options to specify a standard
frame rate like 30 or 60 before making other changes.

To make the interface clean, L<ffmpeg(1)> is run with the C<-loglevel fatal>
and it doesn't provide the best error statements.  Frankly, there are no
good ffmpeg error statements for end-users.  But, these are particularly
uninformative.  So, be aware of that when failures occur.  The best choice
is to run win C<-n> or C<-dry-run> mode and copy/paste the commandline you
get there.

=head1 EXIT CODES

=over

=item Z<>0

B<clips> ran and exited normally.

=item Z<>1

A command-line token was not understood

=item Z<>2

The first argument after the destination file must be the first input
file, but it was not.

=item Z<>3

A clip was specified that ends after the end of the input file it is to
be pulled from.

=item Z<>4

There was a token syntax error.  Tokens were uses which require another
argument to be present which was not.

=item Z<>5

In establishing a group, an unknown option was presented to merge
group items.

=item Z<>6

An crop definition expands outside the boundary of the input.

=item Z<>7

An attempt was made to overlay without an input to do so with.  This is
a command-line token error which most likely occured from a missing
clip specification sequence.

=item Z<>8

An error was made in specifying overlay parameters.

=item Z<>9

An undefined stacking parameter was sent to group:stack

=item Z<>10

A speed change parameter was entered out of the allowed range.

=item Z<>11

A request was made to make a transition, fade, etc. that would start or
end beyond the actual length of the clip.

=item Z<>12

A reference was made to a file placeholder which does not exist.

=item Z<>100

An unknown error occured which caused the tree structure to be invalid.

=item Z<>101

A Macro expansion sent undefined.  This is most likely a programmers
error; however, it could possibly be the result of a user defined filter.

=back

=head1 SEE ALSO

L<ffmpeg(1)>, L<ffmpeg-filters(1)>, L<mpv(1)>

=head1 AUTHOR

William Totten

=head1 LICENSE

BSD 3-Clause License

=head1 COPYRIGHT

  Copyright (c) 2026, William Totten
  
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  
  1. Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
  
  2. Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
  
  3. Neither the name of the copyright holder nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=cut

